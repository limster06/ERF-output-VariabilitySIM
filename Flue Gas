import math
import random
from typing import Dict, Optional

SIGMA = 5.670374419e-8  # Stefan–Boltzmann constant [W/m²/K⁴]

def Flue_gas_losses(
    Q_chem_MJ: float,
    tau_s: float = 3600,     # modelling period in seconds (default: 1 hour)
    *,
    # --- Nominal baseline values (for calibration) ---
    T_fe_nom_K: float = 1250.0,   # furnace exit gas temp [K] (~977 °C)
    T_amb_nom_K: float = 293.0,   # ambient temp [K] (~20 °C)
    mdot_nom_kg_s: float = 20.0,  # flue gas mass flow [kg/s]
    cp_nom_J_kgK: float = 1150.0, # specific heat of flue gas [J/kg/K]
    UA_nom_W_K: float = 1200.0,   # heat loss UA of path walls [W/K]
    A_leak_nom_m2: float = 0.0015,  # leakage area [m²]
    dP_nom_Pa: float = 5.0,         # pressure difference [Pa]
    rho_gas_nom: float = 0.6,       # density of hot flue gas [kg/m³]
    Cd_nom: float = 0.6,            # discharge coefficient
    target_pct: float = 0.02,       # target ~2% of Q_chem

    # --- Day-to-day variability (stochastic drivers) ---
    T_fe_mean_K: float = 1250.0, T_fe_sd_K: float = 60.0,
    T_amb_mean_K: float = 293.0, T_amb_sd_K: float = 8.0,
    mdot_mean_kg_s: float = 20.0, mdot_sd_kg_s: float = 3.0,
    cp_mean_J_kgK: float = 1150.0, cp_sd_J_kgK: float = 60.0,
    UA_logn_mu: float = 0.0, UA_logn_sigma: float = 0.25, UA_cap_mult: float = 2.5,
    A_leak_logn_mu: float = math.log(0.0015), A_leak_logn_sigma: float = 1.0, A_leak_cap_m2: float = 0.02,
    dP_mean_Pa: float = 4.0, dP_sd_Pa: float = 2.0,
    rho_gas_mean: float = 0.6, rho_gas_sd: float = 0.08,

    rng: Optional[random.Random] = None,
) -> Dict[str, float]:
    """
    Process 3.2: Pre-boiler flue-gas losses with random variability.
    Physics basis: heat loss from hot flue gas to ambient (UA model + leakage).
    Calibrated so mean loss ≈ target_pct * Q_chem.
    """
    rng = rng or random.Random()

    def _clip(x, lo, hi): 
        return max(lo, min(hi, x))

    # --- 1) Nominal baseline for calibration ---
    C_nom_WK = mdot_nom_kg_s * cp_nom_J_kgK
    NTU_nom = UA_nom_W_K / max(1e-9, C_nom_WK)
    eps_nom = 1.0 - math.exp(-NTU_nom)   # heat exchanger effectiveness
    ΔT_nom = max(0.0, T_fe_nom_K - T_amb_nom_K)
    Qdot_path_nom_W = eps_nom * C_nom_WK * ΔT_nom

    mdot_leak_nom = Cd_nom * A_leak_nom_m2 * math.sqrt(max(0.0, 2.0 * rho_gas_nom * dP_nom_Pa))
    Qdot_leak_nom_W = mdot_leak_nom * cp_nom_J_kgK * ΔT_nom

    Qdot_nom_W = Qdot_path_nom_W + Qdot_leak_nom_W
    loss_nom_MJ = Qdot_nom_W * tau_s / 1e6

    # calibration factor
    alpha = (target_pct * Q_chem_MJ / loss_nom_MJ) if loss_nom_MJ > 0 else 1.0

    # --- 2) Random daily draws ---
    T_fe_K  = _clip(rng.normalvariate(T_fe_mean_K, T_fe_sd_K), 900.0, 1500.0)
    T_amb_K = _clip(rng.normalvariate(T_amb_mean_K, T_amb_sd_K), 250.0, 320.0)
    mdot    = _clip(rng.normalvariate(mdot_mean_kg_s, mdot_sd_kg_s), 5.0, 60.0)
    cp_gas  = _clip(rng.normalvariate(cp_mean_J_kgK, cp_sd_J_kgK), 900.0, 1400.0)

    UA_mult = min(math.exp(rng.normalvariate(UA_logn_mu, UA_logn_sigma)), UA_cap_mult)
    UA_W_K = UA_nom_W_K * UA_mult

    A_leak = min(math.exp(rng.normalvariate(A_leak_logn_mu, A_leak_logn_sigma)), A_leak_cap_m2)
    dP_Pa  = _clip(rng.normalvariate(dP_mean_Pa, dP_sd_Pa), 0.0, 30.0)
    rho_g  = _clip(rng.normalvariate(rho_gas_mean, rho_gas_sd), 0.3, 1.2)

    # --- 3) Physics calculation for this draw ---
    C_WK = max(1e-9, mdot * cp_gas)
    NTU = UA_W_K / C_WK
    eps = 1.0 - math.exp(-NTU)
    ΔT = max(0.0, T_fe_K - T_amb_K)

    Qdot_path_W = eps * C_WK * ΔT
    mdot_leak = Cd_nom * A_leak * math.sqrt(max(0.0, 2.0 * rho_g * dP_Pa))
    Qdot_leak_W = mdot_leak * cp_gas * ΔT

    Qdot_total_W = Qdot_path_W + Qdot_leak_W
    loss_uncal_MJ = Qdot_total_W * tau_s / 1e6

    # Apply calibration factor
    loss_MJ = alpha * loss_uncal_MJ
    loss_pct = loss_MJ / Q_chem_MJ if Q_chem_MJ > 0 else 0.0

    return {
        "loss_MJ": loss_MJ,
        "loss_pct": loss_pct,
        "uncal_loss_MJ": loss_uncal_MJ,
        "alpha_cal": alpha,
        # sampled variables (for trace/debug)
        "samples_T_fe_K": T_fe_K,
        "samples_T_amb_K": T_amb_K,
        "samples_mdot_kg_s": mdot,
        "samples_cp_J_kgK": cp_gas,
        "samples_UA_W_K": UA_W_K,
        "samples_A_leak_m2": A_leak,
        "samples_dP_Pa": dP_Pa,
        "samples_rho_gas": rho_g,
        "samples_NTU": NTU,
        "samples_eps": eps,
    }

# --- Example usage ---
# result = process_3_2_random(Q_chem_MJ=50000.0, tau_s=3600)
# print(result["loss_pct"], result["loss_MJ"])

import numpy as np

def Flue_gas_losses_batch(Q_chem_MJ_array, tau_s=3600, *, seed=None, **kwargs):
    """
    Run Process 3.2 (flue-gas losses) for an array of Q_chem values.

    Parameters
    ----------
    Q_chem_MJ_array : array-like
        Sequence of chemical energy values [MJ] per timestep.
    tau_s : float, default 3600
        Period length in seconds (e.g. 3600 for 1 hour).
    seed : int | None
        Random seed for reproducibility.
    **kwargs :
        Extra keyword args forwarded to `process_3_2_random`.

    Returns
    -------
    dict of numpy arrays (one element per timestep).
    """
    rng = random.Random(seed)
    q = np.asarray(Q_chem_MJ_array, dtype=float)

    outs = [Flue_gas_losses(float(Q), tau_s, rng=rng, **kwargs) for Q in q]

    keys = outs[0].keys()
    return {k: np.array([o[k] for o in outs]) for k in keys}

res32 = Flue_gas_losses_batch(E_postradiation, tau_s=3600, seed=123)

E_postflue=E_postradiation-res32["loss_MJ"]

print(E_postflue) 
